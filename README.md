# red-black_tree
## Свойства
Красно-чёрным называется бинарное поисковое дерево, у которого каждому узлу сопоставлен дополнительный атрибут — цвет и для которого выполняются следующие свойства:
1.     Каждая вершина — либо красная, либо черная
2.     Каждый лист — черный
3.     Если вершина красная, оба ее ребенка черные
4.     Все пути, идущие от корня к листьям, содержат одинаковое количество черных вершин
Будем называть чёрной высотой (англ. black-height) вершины x число чёрных вершин на пути из x в лист.
Красно-чёрное дерево с N ключами имеет высоту h=O(logN).

## Операции
### Вставка элемента
Каждый элемент вставляется вместо листа, поэтому для выбора места вставки идём от корня до тех пор, пока указатель на следующего сына не станет nil (то есть этот сын — лист). Вставляем вместо него новый элемент с нулевыми потомками и красным цветом. Теперь проверяем балансировку. Если отец нового элемента черный, то никакое из свойств дерева не нарушено. Если же он красный, то нарушается свойство 3, для исправления достаточно рассмотреть два случая: 
1. "Дядя" этого узла тоже красный. Тогда, чтобы сохранить свойства 3и 4, просто перекрашиваем "отца" и "дядю" в чёрный цвет, а "деда" — в красный. В таком случае черная высота в этом поддереве одинакова для всех листьев и у всех красных вершин "отцы" черные. Проверяем, не нарушена ли балансировка. Если в результате этих перекрашиваний мы дойдём до корня, то в нём в любом случае ставим чёрный цвет, чтобы дерево удовлетворяло свойству

        binTree *fixInsert(binTree *node, binTree *root) {
            if(root->left == nullptr && root->right == nullptr) {
                node->color = black;
                return root; //выставление цвета для корня дерева
            }
            while(node->parent->color == red) {
                if(node->parent->parent->left == node->parent) {
                    if(node->parent->parent->right && node->parent->parent->right->color == red) {
                        //если дядя есть и он красный
                        node->parent->color = black;//меняем цвет отца
                        node->parent->parent->right->color = black;//так же меняем цвет дяди
                        node->parent->parent->color = red;//меняем цвет деда

2. "Дядя" чёрный. Если выполнить только перекрашивание, то может нарушиться постоянство чёрной высоты дерева по всем ветвям. Поэтому выполняем поворот. Если добавляемый узел был правым потомком, то необходимо сначала выполнить левое вращение, которое сделает его левым потомком. Таким образом, свойство 3 и постоянство черной высоты сохраняются.


        }else {
                        if(node->parent->right == node) {
                            node = node->parent;
                            //меняем местами красные и черные элементы(отца и ребенка)
                            // для сохранения черной высоты
                            rotateLeft(node);
                        }
                        node->parent->color = black;
                        node->parent->parent->color = red;
                        rotateRight(node->parent->parent);

                    }

### Полный псевдокод

        func insert(key)
            Node t = Node(key, red, nil, nil) // конструктор, в который передаем ключ, цвет, левого и правого ребенка 
            if дерево пустое
                root = t
                t.parent = nil
            else
                Node p = root
                Node q = nil
                while p != nil // спускаемся вниз, пока не дойдем до подходящего листа 
                    q = p
                    if p.key < t.key
                        p = p.right
                    else
                        p = p.left
                t.parent = q
                // добавляем новый элемент красного цвета 
                if q.key < t.key
                    q.right = t
                else
                    q.left = t
             fixInsertion(t) // проверяем, не нарушены ли свойства красно-черного дерева 
### Балансировка
       func fixInsertion(t: Node)
          if t — корень
              t = black
              return
          // далее все предки упоминаются относительно t 
          while "отец" красный // нарушается свойство 3
              if "отец" — левый ребенок
                  if есть красный "дядя"
                       parent = black
                       uncle = black
                       grandfather = red
                       t = grandfather 
                  else
                      if t — правый сын
                          t = parent
                          leftRotate(t)
                      parent = black
                      grandfather = red
                      rightRotate(grandfather)
              else // "отец" — правый ребенок 
                  
          root = black // восстанавливаем свойство корня 
 
 ### Удаление
Удаление происходит по тому же принципу что и в наивной реализации бинарного дерева поиска, однако если мы удаляем черный элемент, то изменяется черная высота, следовательно следует отбалансировать дерево

Если брат этого ребёнка красный, то делаем вращение вокруг ребра между отцом и братом, тогда брат становится родителем отца. Красим его в чёрный, а отца — в красный цвет, сохраняя таким образом черную высоту дерева. Хотя все пути по-прежнему содержат одинаковое количество чёрных узлов, сейчас x имеет чёрного брата и красного отца. Таким образом, мы можем перейти к следующему шагу.

            func fixDeleting(p: Node)
                // далее родственные связи относительно p
                while p — черный узел и не корень
                     if p — левый ребенок
                         if "брат" красный 
                             brother = black
                             parent = red
                             leftRotate(parent)
                       
Если брат текущей вершины был чёрным, то получаем три случая: 
Оба ребёнка у брата чёрные. Красим брата в красный цвет и рассматриваем далее отца вершины. Делаем его черным, это не повлияет на количество чёрных узлов на путях, проходящих через b, но добавит один к числу чёрных узлов на путях, проходящих через x, восстанавливая тем самым влиянние удаленного чёрного узла. Таким образом, после удаления вершины черная глубина от отца этой вершины до всех листьев в этом поддереве будет одинаковой. 

                     if у "брата" черные дети             // случай 1:"брат" красный с черными детьми
                         brother = red

Если у брата правый ребёнок чёрный, а левый красный, то перекрашиваем брата и его левого сына и делаем вращение. Все пути по-прежнему содержат одинаковое количество чёрных узлов, но теперь у x есть чёрный брат с красным правым потомком, и мы переходим к следующему случаю. Ни x, ни его отец не влияют на эту трансформацию. 

               else
                 if правый ребенок "брата" черный // случай, рассматриваемый во втором подпункте:
                     brother.left = black         // "брат" красный с черными правым ребенком
                     brother = red
                     rightRotate(brother)

Если у брата правый ребёнок красный, то перекрашиваем брата в цвет отца, его ребёнка и отца — в чёрный, делаем вращение. Поддерево по-прежнему имеет тот же цвет корня, поэтому свойства не нарушаются. Но у x теперь появился дополнительный чёрный предок: либо a стал чёрным, или он и был чёрным и b был добавлен в качестве чёрного дедушки. Таким образом, проходящие через x пути проходят через один дополнительный чёрный узел. Выходим из алгоритма. 

                 brother.colour = parent.colour   // случай, рассматриваемый в последнем подпункте
                 parent = black
                 brother.right = black
                 leftRotate(parent)
                 p = root

